//! Byte-level layout assertions that protect the zero-copy contract relied upon
//! by the on-chain program and any off-chain indexers.
//!
//! Rationale and context:
//! - The program frequently interprets account bytes directly as structs to
//!   avoid allocations and copies (zero-copy). This is a critical performance
//!   optimization on Solana where compute and account I/O are constrained.
//! - Because we depend on raw memory representations, small changes to field
//!   order, type widths, or alignment can create subtle, security-impacting
//!   regressions. These tests act as an explicit contract: if you change the
//!   struct layout you must also update migration scripts, rent calculations,
//!   and any consumers that depend on the byte-level ABI.

use super::helpers::{
    assert_price_point_eq, chunk_from_bytes, chunk_to_bytes, deterministic_price_point,
    empty_chunk, BUFFER_SIZE_U16,
};
use crate::state::historical_chunk::{HistoricalChunk, PricePoint};
use crate::utils::constants::BUFFER_SIZE;
use anchor_lang::{Space, ZeroCopy};
use bytemuck::{bytes_of, Pod, Zeroable};
use std::mem::{align_of, size_of};

/// Enforces the documented size/alignment contract for `HistoricalChunk`.
///
/// Why enforce size/alignment explicitly:
/// - Rent, allocation, and off-chain tooling rely on a fixed account size.
/// - Zero-copy casts assume a particular alignment (here 16 bytes because of
///   i128 fields). Misalignment can cause undefined behaviour when pointer
///   casting or transmuting memory.
/// - Any non-trivial change requires a migration plan; failing CI here acts as
///   an early safegaurd to prevent accidental deployment mismatches.
#[test]
fn historical_chunk_layout_contract() {
    const EXPECTED_PRICE_POINT_SIZE: usize = 48;
    assert_eq!(
        size_of::<PricePoint>(),
        EXPECTED_PRICE_POINT_SIZE,
        "PricePoint layout drifted; re-evaluate serialization contracts"
    );
    assert_eq!(
        align_of::<PricePoint>(),
        16,
        "PricePoint alignment must remain 16 bytes due to i128 fields"
    );

    const EXPECTED_CHUNK_SIZE: usize = 2 + 2 + 2 + 2 // chunk_id, head, tail, count
        + 8 // creation_timestamp
        + 32 // next_chunk
        + 32 // oracle_state
        + EXPECTED_PRICE_POINT_SIZE * BUFFER_SIZE
        + 1 // bump
        + 511; // reserved padding

    assert_eq!(
        size_of::<HistoricalChunk>(),
        EXPECTED_CHUNK_SIZE,
        "HistoricalChunk size drifted; update account sizing calculators"
    );
    assert_eq!(
        align_of::<HistoricalChunk>(),
        16,
        "HistoricalChunk alignment driven by PricePoint i128 fields"
    );
}

/// `INIT_SPACE` constants generated by Anchor are used when allocating
/// accounts (e.g., `initialize_oracle`). We assert the derived constant matches
/// the raw `size_of` so tooling and rent calculations remain correct.
///
/// Trade-offs:
/// - Relying on Anchor's derived constants keeps allocation code simple, but
///   it also means layout changes in Rust must be mirrored in deployment
///   tooling. These tests make that coupling explicit and fail fast in CI.
#[test]
fn historical_chunk_init_space_matches_struct_layout() {
    const ACCOUNT_DISCRIMINATOR: usize = 8;
    assert_eq!(
        HistoricalChunk::INIT_SPACE,
        size_of::<HistoricalChunk>(),
        "HistoricalChunk::INIT_SPACE changed; update InitializeOracle account sizing"
    );
    assert_eq!(
        ACCOUNT_DISCRIMINATOR + HistoricalChunk::INIT_SPACE,
        ACCOUNT_DISCRIMINATOR + size_of::<HistoricalChunk>(),
        "Discriminator + INIT_SPACE must reflect actual rent-exempt byte size"
    );

    // PricePoint derives InitSpace as well; keep it consistent for downstream
    // allocators that may rely on the constant when building chunks off-chain.
    assert_eq!(
        PricePoint::INIT_SPACE,
        size_of::<PricePoint>(),
        "PricePoint::INIT_SPACE changed; re-evaluate chunk sizing calculators"
    );
}

/// Validates zero-copy trait contracts that allow safe casts from account
/// bytes without heap allocations.
///
/// Why these trait checks matter:
/// - `Pod` ensures a type is safe to reinterpret as raw bytes (no drop
///   glue, properly aligned, `repr(C)`-like guarantees). `Zeroable` ensures an
///   all-zero bit pattern is valid for the type. `ZeroCopy` is an Anchor
///   marker ensuring the type is safe for account-load zero-copy semantics.
/// - Tests assert these constraints explicitly so future refactors don't
///   accidentally remove or invalidate the zero-copy guarantees.
#[test]
fn zero_copy_trait_contracts() {
    fn assert_pod<T: Pod>() {}
    fn assert_zeroable<T: Zeroable>() {}
    fn assert_zero_copy<T: ZeroCopy>() {}

    assert_pod::<PricePoint>();
    assert_zeroable::<PricePoint>();
    assert_zero_copy::<HistoricalChunk>();
}

/// Padding and reserved bytes must remain zero to avoid leaking
/// uninitialised memory into serialized account images.
///
/// Security rationale:
/// - Non-deterministic padding can leak stack/heap contents into account
///   images, create fingerprinting surfaces, or cause equality/hash
///   mismatches between nodes. Keeping padding deterministic (zeroed) is a
///   low-risk, high-value invariant.
#[test]
fn padding_and_reserved_bytes_remain_zero() {
    let mut chunk = empty_chunk();
    for idx in 0..(BUFFER_SIZE as i64) {
        chunk.push(deterministic_price_point(idx));
    }

    assert!(
        chunk.reserved.iter().all(|byte| *byte == 0),
        "reserved padding mutated unexpectedly"
    );

    let serialized = chunk_to_bytes(&chunk);
    let padding_slice = &serialized[serialized.len() - chunk.reserved.len()..];
    assert!(
        padding_slice.iter().all(|byte| *byte == 0),
        "serialized image leaked non-zero padding"
    );

    let reread = chunk_from_bytes(&serialized);
    assert_eq!(reread.count, BUFFER_SIZE_U16);
    assert_eq!(reread.head, chunk.head);
    assert_eq!(reread.tail, chunk.tail);
    assert_price_point_eq(&reread.price_points[0], &chunk.price_points[0]);
    assert!(
        reread.reserved.iter().all(|byte| *byte == 0),
        "padding should deserialize back to zeros"
    );
}

/// Historical chunks and price points rely on zero defaulting; ensure the
/// derived implementations continue to zero every field.
///
/// Motivation:
/// - Zeroed defaults provide a conservative, safe baseline for newly
///   allocated accounts and minimize the chance of accidental trust in
///   uninitialised fields. Tests assert both semantic zeros (fields) and the
///   raw byte-level zeros to guard against hidden padding changes.
#[test]
fn default_values_are_zeroed() {
    let point = PricePoint::default();
    assert_eq!(point.price, 0);
    assert_eq!(point.volume, 0);
    assert_eq!(point.conf, 0);
    assert_eq!(point.timestamp, 0);
    assert!(
        bytes_of(&point).iter().all(|byte| *byte == 0),
        "PricePoint default must be fully zeroed"
    );

    let chunk = empty_chunk();
    assert_eq!(chunk.count, 0);
    assert_eq!(chunk.head, 0);
    assert_eq!(chunk.tail, 0);
    assert!(chunk.price_points.iter().all(|p| p.timestamp == 0));
    assert!(chunk.reserved.iter().all(|byte| *byte == 0));
}
